<!-- Footer -->
<footer class="wrapper style1 align-center">
    <div class="inner">
        <ul class="icons">
            {{ with .Site.Params.social.github }}<li><a target="_blank" href="{{.}}" class="icon brands style2 fa-github"><span class="label">Github</span></a></li>{{end}}
            {{ with .Site.Params.social.twitter }}<li><a target="_blank" href="{{.}}" class="icon brands style2 fa-twitter"><span class="label">Twitter</span></a></li>{{end}}
            {{ with .Site.Params.social.instagram }}<li><a target="_blank" href="{{.}}" class="icon brands style2 fa-instagram"><span class="label">Instagram</span></a></li>{{end}}
            {{ with .Site.Params.social.linkedin }}<li><a target="_blank" href="{{.}}" class="icon brands style2 fa-linkedin"><span class="label">LinkedIn</span></a></li>{{end}}
            {{ with .Site.Params.social.email }}<li><a target="_blank" href="mailto:{{.}}" class="fav icon style2 fa-envelope"><span class="label">Email</span></a></li>{{end}}
        </ul>
        <p>Hugo Story &copy; 2020 <a target="_blank" href="https://github.com/caressofsteel/">CaressOfSteel</a><span class="footerspacer icon fa-diamond"></span>
            Ported from <a target="_blank" href="https://html5up.net/uploads/demos/story/">Story</a> by HTML5UP<span class="footerspacer icon fa-diamond"></span>
            Images courtesy of <a target="_blank" href="https://unsplash.com">Unsplash</a></p>
</div>
</footer>

<script>
(function () {
  const nav = document.getElementById('floating-nav');
  if (!nav) return;

  const inner  = nav.querySelector('.floating-nav__inner') || nav;
  const links  = Array.from(nav.querySelectorAll('a[data-scroll]'));

  // Normalize any href to a plain "#id" (works for "#id", "/#id", "https://.../#id")
  function getHash(a) {
    try {
      const raw = a.getAttribute('href') || '';
      if (!raw) return '';
      if (raw.startsWith('#')) return raw;                        // "#id"
      const url = new URL(raw, window.location.origin);           // "/#id" or absolute
      return url.hash || '';
    } catch { return ''; }
  }

  // Build list of target IDs and sections
  const hashes = links.map(getHash).filter(h => h && h.length > 1);
  const ids    = hashes.map(h => h.slice(1));
  const sections = ids.map(id => document.getElementById(id)).filter(Boolean);

  const banner = document.getElementById('banner');

  /* --- Show/hide nav based on banner visibility --- */
  function showNav() { nav.classList.add('is-visible'); }
  function hideNav() { nav.classList.remove('is-visible'); }

  if (banner) {
    const vis = new IntersectionObserver(([entry]) => {
      if (entry && entry.isIntersecting && entry.intersectionRatio > 0.2) hideNav();
      else showNav();
    }, { threshold: [0, 0.2, 0.4] });
    vis.observe(banner);
  } else {
    showNav();
  }

  /* --- Active link helpers --- */
  function setActiveByHash(hash) {
    let any = false;
    links.forEach(a => {
      const active = (getHash(a) === hash);
      a.classList.toggle('is-active', active);
      any = any || active;
    });
    inner.classList.toggle('has-active', any);
  }

  function setActive(id) {
    setActiveByHash('#' + id);
  }

  /* --- Scroll spy (mid-viewport = active) --- */
  const spy = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (entry.isIntersecting) setActive(entry.target.id);
    });
  }, {
    rootMargin: '-45% 0px -45% 0px',
    threshold: 0
  });
  sections.forEach(sec => spy.observe(sec));

  /* --- Initialize from current URL and keep in sync on hash changes --- */
  setActiveByHash(window.location.hash || '');
  window.addEventListener('hashchange', () => setActiveByHash(window.location.hash || ''));
})();
</script>




<script>
(function () {
  const wrap   = document.getElementById('research-timeline');
  const iframe = document.getElementById('lab-timeline');
  if (!wrap || !iframe) return;

  let fired = false;

  const io = new IntersectionObserver(([entry]) => {
    if (fired || !entry) return;

    // Fire as soon as ANY pixel of the timeline frame is visible
    if (entry.isIntersecting && entry.intersectionRatio > 0) {
      fired = true;

      // 1) Show spinner overlay immediately
      wrap.classList.add('is-loading');

      // 2) Kick the iframe load if still blank
      const url = iframe.getAttribute('data-src');
      if (iframe.src === 'about:blank' && url) iframe.src = url;

      // 3) Keep spinner for 2s, then fade it out (CSS handles fade)
      setTimeout(() => {
        wrap.classList.remove('is-loading');
      }, 2000);

      io.disconnect();
    }
  }, { threshold: [0] });

  io.observe(wrap);
})();
</script>


<script>
(function () {
  function smoothScrollTo(selector) {
    const el = document.querySelector(selector);
    if (!el) return;
    // Your CSS anchor-offset trick handles the fixed nav, so a simple scroll is fine:
    el.scrollIntoView({ behavior: "smooth", block: "start" });
  }

  window.addEventListener("message", (e) => {
    // only accept messages from our own origin (same-origin iframe)
    if (e.origin !== window.location.origin) return;
    const data = e.data || {};
    if (data.type === "lab-nav" && typeof data.target === "string") {
      smoothScrollTo(data.target);
    }
  });
})();
</script>


<script>
/* Snap between sections on wheel/swipe, but allow scrolling inside scrollable areas */
document.addEventListener("DOMContentLoaded", () => {
  // Sections that can be navigated to (IDs must match your floating-nav hrefs)
  const sections = Array.from(document.querySelectorAll('section[id]'));
  if (!sections.length) return;

  // Helper: in-view "current" section (by viewport center)
  const currentSection = () => {
    const mid = window.innerHeight / 2;
    for (const s of sections) {
      const r = s.getBoundingClientRect();
      if (r.top <= mid && r.bottom >= mid) return s;
    }
    // fallback: nearest
    return sections.slice().sort((a,b) => Math.abs(a.getBoundingClientRect().top) - Math.abs(b.getBoundingClientRect().top))[0];
  };

  // Helper: is the event target inside an element that can scroll further?
  function canScrollWithin(target, deltaY) {
    let el = target;
    // You can also add a class like ".allow-scroll" if you want to whitelist explicitly
    while (el && el !== document.body) {
      const s = getComputedStyle(el);
      const overflowY = s.overflowY;
      const scrollable = (overflowY === 'auto' || overflowY === 'scroll');
      if (scrollable && el.scrollHeight > el.clientHeight) {
        if (deltaY > 0) { // scrolling down
          if (el.scrollTop + el.clientHeight < el.scrollHeight - 1) return true; // can scroll down inside
        } else if (deltaY < 0) { // scrolling up
          if (el.scrollTop > 0) return true; // can scroll up inside
        }
      }
      el = el.parentElement;
    }
    return false;
  }

  // Smoothly scroll to a specific section
  function goToSection(sec) {
    if (!sec) return;
    // Prevent rapid-fire repeats
    if (goToSection.locked) return;
    goToSection.locked = true;
    sec.scrollIntoView({ behavior: 'smooth', block: 'start' });
    setTimeout(() => { goToSection.locked = false; }, 600); // unlock after animation
  }

  // Find next/prev sections relative to the current one
  function neighborSection(direction) {
    const cur = currentSection();
    const i = sections.indexOf(cur);
    if (i === -1) return null;
    return direction > 0 ? sections[Math.min(i + 1, sections.length - 1)]
                         : sections[Math.max(i - 1, 0)];
  }

  // Wheel handler: if not scrolling inside a scrollable element, snap
  function onWheel(e) {
    const dy = e.deltaY;
    if (canScrollWithin(e.target, dy)) return;  // let inner scrolling happen
    // At edges inside the section? then snap
    e.preventDefault();
    const target = neighborSection(dy > 0 ? 1 : -1);
    if (target) goToSection(target);
  }
  window.addEventListener('wheel', onWheel, { passive: false });

  // Touch swipe (mobile): detect vertical swipe and snap if not inside scrollable
  let touchStartY = null, touchStartX = null;
  window.addEventListener('touchstart', (e) => {
    const t = e.changedTouches[0]; touchStartY = t.clientY; touchStartX = t.clientX;
  }, { passive: true });
  window.addEventListener('touchmove', (e) => {
    const t = e.changedTouches[0];
    if (touchStartY == null) return;
    const dy = touchStartY - t.clientY;
    const dx = Math.abs(touchStartX - t.clientX);
    // Ignore mostly horizontal gestures
    if (dx > Math.abs(dy)) return;
    if (canScrollWithin(e.target, dy)) return;  // let inner scrolling happen
    // Threshold so minor moves don't trigger
    if (Math.abs(dy) < 24) return;
    e.preventDefault();
    const target = neighborSection(dy > 0 ? 1 : -1);
    if (target) goToSection(target);
  }, { passive: false });

  // Keyboard: Space/PageUp/PageDown/Arrows snap between sections, but allow inner scroll when possible
  window.addEventListener('keydown', (e) => {
    const keys = ['ArrowDown','PageDown',' ' ,'ArrowUp','PageUp','Home','End'];
    if (!keys.includes(e.key)) return;
    // If focus is inside a scrollable area that can still scroll, allow default
    const dir = (e.key === 'ArrowDown' || e.key === 'PageDown' || e.key === ' ') ? 1
               : (e.key === 'ArrowUp' || e.key === 'PageUp') ? -1 : 0;
    if (dir !== 0 && canScrollWithin(document.activeElement || document.body, dir)) return;
    e.preventDefault();
    if (e.key === 'Home') return goToSection(sections[0]);
    if (e.key === 'End')  return goToSection(sections[sections.length-1]);
    const target = neighborSection(dir);
    if (target) goToSection(target);
  });

  // Make your floating-nav links use the same smooth snapping
  document.querySelectorAll('#floating-nav a[data-scroll]').forEach(a => {
    a.addEventListener('click', (e) => {
      const href = a.getAttribute('href') || '';
      if (!href.startsWith('#')) return;
      e.preventDefault();
      const id = href.slice(1);
      const sec = document.getElementById(id);
      if (sec) goToSection(sec);
    });
  });
});
</script>

