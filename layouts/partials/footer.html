<!-- Footer -->
<footer class="wrapper style1 align-center">
    <div class="inner">
        <ul class="icons">
            {{ with .Site.Params.social.github }}<li><a target="_blank" href="{{.}}" class="icon brands style2 fa-github"><span class="label">Github</span></a></li>{{end}}
            {{ with .Site.Params.social.twitter }}<li><a target="_blank" href="{{.}}" class="icon brands style2 fa-twitter"><span class="label">Twitter</span></a></li>{{end}}
            {{ with .Site.Params.social.instagram }}<li><a target="_blank" href="{{.}}" class="icon brands style2 fa-instagram"><span class="label">Instagram</span></a></li>{{end}}
            {{ with .Site.Params.social.linkedin }}<li><a target="_blank" href="{{.}}" class="icon brands style2 fa-linkedin"><span class="label">LinkedIn</span></a></li>{{end}}
            {{ with .Site.Params.social.email }}<li><a target="_blank" href="mailto:{{.}}" class="fav icon style2 fa-envelope"><span class="label">Email</span></a></li>{{end}}
        </ul>
        <p>Hugo Story &copy; 2020 <a target="_blank" href="https://github.com/caressofsteel/">CaressOfSteel</a><span class="footerspacer icon fa-diamond"></span>
            Ported from <a target="_blank" href="https://html5up.net/uploads/demos/story/">Story</a> by HTML5UP<span class="footerspacer icon fa-diamond"></span>
            Images courtesy of <a target="_blank" href="https://unsplash.com">Unsplash</a></p>
</div>
</footer>

<script>
(function () {
  const nav = document.getElementById('floating-nav');
  if (!nav) return;

  const inner  = nav.querySelector('.floating-nav__inner') || nav;
  const links  = Array.from(nav.querySelectorAll('a[data-scroll]'));

  // Normalize any href to a plain "#id" (works for "#id", "/#id", "https://.../#id")
  function getHash(a) {
    try {
      const raw = a.getAttribute('href') || '';
      if (!raw) return '';
      if (raw.startsWith('#')) return raw;                        // "#id"
      const url = new URL(raw, window.location.origin);           // "/#id" or absolute
      return url.hash || '';
    } catch { return ''; }
  }

  // Build list of target IDs and sections
  const hashes = links.map(getHash).filter(h => h && h.length > 1);
  const ids    = hashes.map(h => h.slice(1));
  const sections = ids.map(id => document.getElementById(id)).filter(Boolean);

  const banner = document.getElementById('banner');

  /* --- Show/hide nav based on banner visibility --- */
  function showNav() { nav.classList.add('is-visible'); }
  function hideNav() { nav.classList.remove('is-visible'); }

  if (banner) {
    const vis = new IntersectionObserver(([entry]) => {
      if (entry && entry.isIntersecting && entry.intersectionRatio > 0.2) hideNav();
      else showNav();
    }, { threshold: [0, 0.2, 0.4] });
    vis.observe(banner);
  } else {
    showNav();
  }

  /* --- Active link helpers --- */
  function setActiveByHash(hash) {
    let any = false;
    links.forEach(a => {
      const active = (getHash(a) === hash);
      a.classList.toggle('is-active', active);
      any = any || active;
    });
    inner.classList.toggle('has-active', any);
  }

  function setActive(id) {
    setActiveByHash('#' + id);
  }

  /* --- Scroll spy (mid-viewport = active) --- */
  const spy = new IntersectionObserver(entries => {
    entries.forEach(entry => {
      if (entry.isIntersecting) setActive(entry.target.id);
    });
  }, {
    rootMargin: '-45% 0px -45% 0px',
    threshold: 0
  });
  sections.forEach(sec => spy.observe(sec));

  /* --- Initialize from current URL and keep in sync on hash changes --- */
  setActiveByHash(window.location.hash || '');
  window.addEventListener('hashchange', () => setActiveByHash(window.location.hash || ''));
})();
</script>




<script>
(function () {
  const wrap   = document.getElementById('research-timeline');
  const iframe = document.getElementById('lab-timeline');
  if (!wrap || !iframe) return;

  let fired = false;

  const io = new IntersectionObserver(([entry]) => {
    if (fired || !entry) return;

    // Fire as soon as ANY pixel of the timeline frame is visible
    if (entry.isIntersecting && entry.intersectionRatio > 0) {
      fired = true;

      // 1) Show spinner overlay immediately
      wrap.classList.add('is-loading');

      // 2) Kick the iframe load if still blank
      const url = iframe.getAttribute('data-src');
      if (iframe.src === 'about:blank' && url) iframe.src = url;

      // 3) Keep spinner for 2s, then fade it out (CSS handles fade)
      setTimeout(() => {
        wrap.classList.remove('is-loading');
      }, 2000);

      io.disconnect();
    }
  }, { threshold: [0] });

  io.observe(wrap);
})();
</script>


<script>
document.addEventListener('DOMContentLoaded', () => {
  /* EDIT THIS LIST to include only the top-level sections you want to lock between */
  const SECTION_IDS = ['research','people']; // add more ids if needed, in page order

  const sections = SECTION_IDS
    .map(id => document.getElementById(id))
    .filter(Boolean);

  if (!sections.length) return;

  const root = document.scrollingElement || document.documentElement;

  function measureBounds() {
    // fresh bounds on every call; robust to dynamic content
    return sections.map(el => {
      const r = el.getBoundingClientRect();
      const top = root.scrollTop + r.top;
      const bottom = top + r.height;
      return { el, top, bottom };
    });
  }

  function currentIndex(bounds) {
    const mid = root.scrollTop + window.innerHeight / 2;
    let idx = bounds.findIndex(b => mid >= b.top && mid <= b.bottom);
    if (idx !== -1) return idx;
    // fallback: nearest
    let best = 0, bestDist = Infinity;
    bounds.forEach((b, i) => {
      const d = Math.min(Math.abs(mid - b.top), Math.abs(mid - b.bottom));
      if (d < bestDist) { best = i; bestDist = d; }
    });
    return best;
  }

  function clampToSection(desiredY, bounds) {
    const i = currentIndex(bounds);
    const b = bounds[i];
    const vh = window.innerHeight;

    // If the section is taller than the viewport, allow scrolling inside it.
    // If it is shorter or equal, lock the viewport at the section's top.
    const minY = b.top;
    const maxY = Math.max(b.top, b.bottom - vh);

    // clamp
    if (desiredY < minY) desiredY = minY;
    if (desiredY > maxY) desiredY = maxY;
    return desiredY;
  }

  function scrollDelta(delta) {
    const bounds = measureBounds();
    const target = clampToSection(root.scrollTop + delta, bounds);
    if (Math.abs(target - root.scrollTop) > 0.1) {
      root.scrollTo({ top: target, left: 0, behavior: 'auto' });
    }
  }

  /* -------- Block crossing between sections -------- */

  // Wheel / trackpad
  window.addEventListener('wheel', (e) => {
    e.preventDefault();                     // block natural page scroll
    scrollDelta(e.deltaY || 0);
  }, { passive: false });

  // Touch
  let touchY = null;
  window.addEventListener('touchstart', (e) => {
    const t = e.changedTouches && e.changedTouches[0];
    touchY = t ? t.clientY : null;
  }, { passive: true });

  window.addEventListener('touchmove', (e) => {
    const t = e.changedTouches && e.changedTouches[0];
    if (!t || touchY == null) return;
    const dy = touchY - t.clientY;          // positive means scroll down
    e.preventDefault();                     // block natural page scroll
    scrollDelta(dy);
    touchY = t.clientY;
  }, { passive: false });

  // Keyboard
  window.addEventListener('keydown', (e) => {
    const k = e.key;
    if (!['ArrowDown','ArrowUp','PageDown','PageUp','Home','End',' '].includes(k)) return;
    e.preventDefault();
    const page = window.innerHeight * 0.9;
    const line = 60;
    let delta = 0;

    if (k === 'ArrowDown') delta =  line;
    if (k === 'ArrowUp')   delta = -line;
    if (k === 'PageDown' || k === ' ') delta =  page;
    if (k === 'PageUp')    delta = -page;

    if (k === 'Home' || k === 'End') {
      const bounds = measureBounds();
      const i = currentIndex(bounds);
      const b = bounds[i];
      const vh = window.innerHeight;
      const topPos = b.top;
      const endPos = Math.max(b.top, b.bottom - vh);
      root.scrollTo({ top: (k === 'Home' ? topPos : endPos), left: 0, behavior: 'auto' });
      return;
    }

    scrollDelta(delta);
  });

  /* -------- Floating-nav: still allowed to jump between sections -------- */
  function getHashFromHref(href) {
    if (!href) return '';
    if (href.startsWith('#')) return href;
    try {
      const u = new URL(href, location.origin);
      if (u.origin === location.origin) return u.hash || '';
    } catch {}
    return '';
  }
  function smoothJump(hash) {
    const el = document.getElementById(hash.slice(1));
    if (!el) return;
    el.scrollIntoView({ behavior: 'smooth', block: 'start' });
  }

  document.querySelectorAll('#floating-nav a[data-scroll]').forEach(a => {
    a.addEventListener('click', (e) => {
      const hash = getHashFromHref(a.getAttribute('href'));
      if (!hash) return;  // external link â†’ default
      e.preventDefault();
      smoothJump(hash);
      history.replaceState(null, '', hash);
    });
  });

  // Respect hash on load
  if (location.hash) setTimeout(() => smoothJump(location.hash), 60);
});
</script>
